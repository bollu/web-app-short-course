#+title:  Object  Implementation of Mini Version of User Directory Application
#+AUTHOR: VLEAD
#+DATE: [2016-05-18 Wed]
#+PROPERTY: results output
#+PROPERTY: exports code
#+SETUPFILE: ../org-templates/level-1.org
#+options: ^:nil
#+LATEX: Literal LaTeX code for export

* Introduction

The implementation of the mini version of the User Directory
Application.  

We start by defining type predicates related to the
entities.

Then we define constructors for the entities =Name= and
=Email=. 



* Initialization

** Imports for Python API
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
# -*- coding: utf-8 -*-
from op_exceptions import AttributeRequired
from utils import *
#+END_SRC


** Imports and Initialization of testcases for Python API

#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
# -*- coding: utf-8 -*-
import unittest
from unittest import TestCase
from datetime import datetime

from src.obj import *
from src.op_exceptions import AttributeRequired

#+END_SRC


** Imports for utility functions

#+BEGIN_SRC python :tangle ../../src/utils.py :eval no

# module to hold all utilities/helper functions

import json

import re


#+END_SRC


** Init Files
#+BEGIN_SRC python :tangle ../../src/__init__.py :eval no
import obj
#+END_SRC

#+BEGIN_SRC python :tangle ../../tests/__init__.py :eval no
print "tests package"
#+END_SRC



* Object Model
** Custom Exceptions
   These are some of the custom exceptions used in the application.

*** AttributeRequired

#+BEGIN_SRC python :tangle ../../src/op_exceptions.py :eval no
class AttributeRequired(Exception):
    str = None

    def __init__(self, str):
        self.str = str

    def __str__(self):
        return repr(self.str)

#+END_SRC




** Utility Functions

*** is_alphabetic_string(value)
    This function take an argument and checks whether the argument contains
    only alphabets.

    This function take an argument and checks whether the
    argument is an alphabetic string.  An alphabetic string
    consists of one or more alphabetic characters, period or
    space.


#+BEGIN_SRC  python :tangle ../../src/utils.py :eval no
def is_alphabetic_string(value):
    if re.search('[^a-zA-Z. ]+', value):
        return False
    else:
        return True
#+END_SRC


**** Tests/Examples
#+begin_src python :tangle ../../tests/test_obj.py :eval no
class Test_is_alphabetic_string(unittest.TestCase):
    """Tests for is_alphabetic_string."""

    def test_one(self):
        """test-Hello"""
        self.assertTrue(is_alphabetic_string("Hello"))

    def test_two(self):
        """test-M N Ray"""
        self.assertTrue(is_alphabetic_string("M. N. Ray"))
#+end_src


There are some false positives, which slip in.  A more
accurate definition of =is_alphabetic_string= should fix
this.

#+begin_src python :tangle utility-tests.py
        def test_three(self):
               """test-. ."""
              self.assertTrue(is_alphabetic_string(".  ."))
unittest.main()
#+end_src


*** is_email(value)
    Email is a type as defined in RFC [[https://tools.ietf.org/html/rfc5321][5321]], [[https://tools.ietf.org/html/rfc5322][5322]] and [[https://tools.ietf.org/html/rfc6531][6531]].
    Following is the constructor for this class.

#+BEGIN_SRC python :tangle ../../src/utils.py :eval no
def is_email(value):
    if re.search('[^@]+@[^@]+\.[^@]+', value):
        return True
    else:
        return False
#+END_SRC

(We may want to instead use the =validate_email= package of
Python.  See [[http://stackoverflow.com/questions/8022530/python-check-for-valid-email-address][this]] Stack Overflow discussion.)


**** Test cases 

To be done.

** Name

*** Construction

     Name is an alphabetical string.

#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
class Name(object):
    value = None
    def __init__(self, value):
        # value: String 
        # if the string contains any non-alphabet and non-space character,
        # raise a type error
        if is_alphabetic_string(value):
            self.value = value
        else:
            raise TypeError('%s is not a Name!' % value)

    def __str__(self):
        return self.value
#+END_SRC


*** Test the Construction
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
class TestName(TestCase):
    TESTING = True
    def test_name_type(self):
        print "test_name_type"
        new_name = Name("John")
        # correct name
        self.assertEqual(new_name.value, "John")
        # incorrect name
        self.assertRaises(TypeError, Name, "123dasd")
#+END_SRC


** Email

*** Construction

     Email is a type as defined in RFC [[https://tools.ietf.org/html/rfc5321][5321]], [[https://tools.ietf.org/html/rfc5322][5322]] and [[https://tools.ietf.org/html/rfc6531][6531]].
     Following is the constructor for this class.

#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
class Email(object):
    value = None
    def __init__(self, value):
        if not is_email(value):
            raise TypeError('%s is not an email!' % value)
        self.value = value

    def __str__(self):
        return self.value
#+END_SRC



*** Test the Construction
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
class TestEmail(TestCase):
    TESTING = True
    def test_email_type(self):
        print "test_email_type"
        new_email = Email("smith@gmail.com")
        # correct name
        self.assertEqual(new_email.value, "smith@gmail.com")
        # incorrect name
        self.assertRaises(TypeError, Email, "@@@@smithgmail.com")
#+END_SRC



** User

*** Mutable Data

     These are the data associated with User type, which are mutable

     + Name
     + Email
     + Role


*** Definition
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
class User():
    name = None
    email = None
    role = None
    users = []     # this is a static variable, accessed by User.users
#+END_SRC


*** Constructor

**** Implementation

    Signature of the constructor of =User= is as follows:

    #+BEGIN_EXAMPLE
    usr = User(name=<object of Name>, email=<object of Email>, 
              role=[<object of Role>, <object of Role> ...])
    #+END_EXAMPLE

#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def __init__(self, **kwargs):
        if 'email' not in kwargs:
            raise AttributeRequired("email is mandatory")

        if 'name' not in kwargs:
            raise AttributeRequired("name is mandatory")

        if 'role' not in kwargs:
            raise AttributeRequired("role is mandatory")

        self.set_email(kwargs['email'])
        self.set_name(kwargs['name'])
        self.set_role(kwargs['role'])
        User.users.append(self)
#+END_SRC


**** Test the constructor
 #+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
class TestUser(TestCase):
    TESTING = True

    def test_user_creation_without_role(self):
        print "test_user_creation_without_role"
        with self.assertRaises(AttributeRequired):
            user = User(name=Name("Robin Smith"), 
                            email=Email("smith@gmail.com"))

    def test_user_creation_with_role(self):
        print "test_user_creation_with_role"
        user = User(name=Name("Robin Smith"), 
                    email=Email("smith@gmail.com"),
                    role=Role(name=Name("admin")))
        self.assertEqual(user.role.name, "admin")   
        self.assertEqual(user.email, "smith@gmail.com")
<<<<<<< HEAD

    def test_user_creation_with_wrong_type(self):
        print "test_user_creation_with_wrong_type"
        with self.assertRaises(TypeError):
            user = User(name=Name("Robin@ Smith"), 
                    email=Email("smith@gmail.com"),
                    role=Role(name=Name("admin")))

=======
>>>>>>> b3676e02383a92698a8ade86940fc168e6f21ee8
 #+END_SRC


*** Functions

**** setEmail
<<<<<<< HEAD
***** Definition
=======
>>>>>>> b3676e02383a92698a8ade86940fc168e6f21ee8
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def set_email(self, email):
        if not isinstance(email, Email):
            raise TypeError('`email` argument should be of type Email.')
        else:
            self.email = email.value
#+END_SRC

<<<<<<< HEAD
***** Constructor
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
    def test_set_email_of_user(self):
        print "test_set_email_of_user"
        user = User(name=Name("Robin Smith"), 
                email=Email("smith@gmail.com"),
                role=Role(name=Name("admin")))
        user.set_email(Email("smith1@gmail.com"));
        self.assertEqual(user.email, "smith1@gmail.com")
#+END_SRC
=======
>>>>>>> b3676e02383a92698a8ade86940fc168e6f21ee8

**** setName
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def set_name(self, name):
        if not isinstance(name, Name):
            raise TypeError('`name` argument should be of type Name.')
        else:
            self.name = name.value
#+END_SRC

**** setRole
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def set_role(self, role):
        if not isinstance(role, Role):
            raise TypeError('`role` argument should be of type Role.')
        else:
            self.role = role
#+END_SRC


**** getRole
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def get_role(self):
        return self.role
#+END_SRC


**** getEmail
 #+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def get_email(self):
        return self.email
 #+END_SRC


**** getName
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def get_name(self):
        return self.name
#+END_SRC


**** getAll: Nil --> set[User]

***** Implementation
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    @staticmethod
    def get_all():
        return User.users
#+END_SRC


***** Test getAll
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
    def test_user_get_all(self):
        print "test_user_get_all"
#        role = Role(name=Name("admin"))
#        user = User(name=Name("Termite"), 
#                    email=Email("tremite@gmail.com"),
#                    role=role)

        users = User.get_all()
        for user in users:
            print user.to_client()
        self.assertEqual("admin", users[0].role.name)
#+END_SRC


**** toClient
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def to_client(self):
        return {
            'name': self.name,
            'email': self.email,
            'role': self.role.to_client()
        }
#+END_SRC



** Role

*** Introduction
   A Role has got certain privileges.  In this current application, the
   privileges are understood 
   
   Different types of roles are:
   - Admin :: An admin is an user who can add, modify and delete other users
        except himself.
   - User :: A User is a user who can view all other users and can modify himself.

*** Mutable Data

     These are the data associated with Role type, which are mutable

     + Name


*** Definition
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
class Role():
    name = None
    roles = []   ## This is a static variable and accessed by Role.roles
#+END_SRC


*** Constructor

    The signature of Role is defined as follows
    #+BEGIN_EXAMPLE
    role = Role(name=<Object of Name>)
    #+END_EXAMPLE

#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def __init__(self, **kwargs):
        if 'name' not in kwargs:
            raise AttributeRequired("name is mandatory")

        self.set_name(kwargs['name'])
        Role.roles.append(self)
#+END_SRC


*** Test Constructor
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
class TestRole(TestCase):
    TESTING = True
    def test_role_creation(self):
        print "test_role_creation"
        role = Role(name=Name("admin"))
        self.assertEqual(role.name, "admin")

#+END_SRC


*** Functions

**** setName
***** Implementation
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def set_name(self, name):
        if not isinstance(name, Name):
            raise TypeError('`name` argument should be of type Name.')
        else:
            self.name = name.value
#+END_SRC

****** Test
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
    def test_role_set_name(self):
        print "test_role_set_name"
        role = Role(name=Name("admin"))
        role.set_name(Name("user"))
        self.assertEqual(role.name, "user")
#+END_SRC


**** getName

#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def get_name(self):
        return self.name
#+END_SRC


**** getAll: Nil --> set[Role]

***** Implementation
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    @staticmethod
    def get_all():
        return Role.roles
#+END_SRC


***** Test getAll: Nil --> set[Role]
 #+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
    def test_role_get_all(self):
        print "test_role_get_all"
#        role = Role(name=Name("admin"))
        roles = Role.get_all()
        for role in roles:
            print role.to_client()
        self.assertEqual("admin", roles[0].name)
 #+END_SRC


**** to_client
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def to_client(self):
        return {
            'name': self.name
        }

#+END_SRC




* Run Test Cases
 
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
if __name__ == '__main__':
    unittest.main()
#+END_SRC


<<<<<<< HEAD
=======

>>>>>>> b3676e02383a92698a8ade86940fc168e6f21ee8
