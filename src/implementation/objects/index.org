#+title:  Object  Implementation of Mini Version of User Directory Application
#+AUTHOR: VLEAD
#+DATE: [2016-05-18 Wed]
#+PROPERTY: results output
#+PROPERTY: exports code
#+SETUPFILE: ../org-templates/level-1.org
#+options: ^:nil
#+LATEX: Literal LaTeX code for export

* Introduction

The object implementation of the mini version of the User Directory
Application.  

We start by some initialization methods

Then we define constructors for the entities =Name= and
=Email=. 


* Initialization

** Imports for Python API
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
# -*- coding: utf-8 -*-
from op_exceptions import AttributeRequired
from op_exceptions import ConstraintError
from op_exceptions import NotAuthorizedError
from utils import *
#+END_SRC


** Imports and Initialization of testcases for Python API

#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
# -*- coding: utf-8 -*-
import unittest
from unittest import TestCase
from datetime import datetime

from src.obj import *
from src.op_exceptions import AttributeRequired
from src.op_exceptions import ConstraintError
from src.op_exceptions import NotAuthorizedError

#+END_SRC


** Imports for utility functions

#+BEGIN_SRC python :tangle ../../src/utils.py :eval no

# module to hold all utilities/helper functions

import json

import re


#+END_SRC


** Init Files
#+BEGIN_SRC python :tangle ../../src/__init__.py :eval no
import obj
#+END_SRC

#+BEGIN_SRC python :tangle ../../tests/__init__.py :eval no
print "tests package"
#+END_SRC



* Object Model

** Custom Exceptions
   These are some of the custom exceptions used in the application.

*** AttributeRequired

#+BEGIN_SRC python :tangle ../../src/op_exceptions.py :eval no
class AttributeRequired(Exception):
    str = None

    def __init__(self, str):
        self.str = str

    def __str__(self):
        return repr(self.str)

#+END_SRC

*** Constraint Error
#+BEGIN_SRC python :tangle ../../src/op_exceptions.py :eval no
class ConstraintError(Exception):
    str = None

    def __init__(self, str):
        self.str = str

    def __str__(self):
        return repr(self.str)

#+END_SRC

*** NotAuthorized Error
#+BEGIN_SRC python :tangle ../../src/op_exceptions.py :eval no
class NotAuthorizedError(Exception):
    str = None

    def __init__(self, str):
        self.str = str

    def __str__(self):
        return repr(self.str)

#+END_SRC

** Utility Functions

*** is_alphabetic_string(value)
    This function take an argument and checks whether the argument contains
    only alphabets.

    This function take an argument and checks whether the
    argument is an alphabetic string.  An alphabetic string
    consists of one or more alphabetic characters, period or
    space.

**** Definition
#+BEGIN_SRC  python :tangle ../../src/utils.py :eval no
def is_alphabetic_string(value):
    if re.search('[^a-zA-Z. ]+', value):
        return False
    else:
        return True
#+END_SRC


**** Tests/Examples
#+begin_src python :tangle ../../tests/test_obj.py :eval no
class Test_is_alphabetic_string(TestCase):
    TESTING = True
    """Tests for is_alphabetic_string."""

    def test_a_alphabetic_string_1(self):
        print "test_a_alphabetic_string_1"
        self.assertTrue(is_alphabetic_string("Hello"))

    def test_a_alphabetic_string_2(self):
        print "test_a_alphabetic_string_2"
        self.assertTrue(is_alphabetic_string("M. N. Ray"))
#+end_src


There are some false positives, which slip in.  A more
accurate definition of =is_alphabetic_string= should fix
this.

#+begin_src python :tangle ../../tests/test_obj.py :eval no
    def test_three(self):
        print "test_a_alphabetic_string_3"
        self.assertTrue(is_alphabetic_string(".  ."))
#+end_src


*** is_email(value)
    Email is a type as defined in RFC [[https://tools.ietf.org/html/rfc5321][5321]], [[https://tools.ietf.org/html/rfc5322][5322]] and [[https://tools.ietf.org/html/rfc6531][6531]].
    Following is the constructor for this class.

**** Definition 
#+BEGIN_SRC python :tangle ../../src/utils.py :eval no
def is_email(value):
    if re.search('[^@]+@[^@]+\.[^@]+', value):
        return True
    else:
        return False
#+END_SRC

(We may want to instead use the =validate_email= package of
Python.  See [[http://stackoverflow.com/questions/8022530/python-check-for-valid-email-address][this]] Stack Overflow discussion.)


**** Test cases 

     To be done.


** Name


*** Construction

     Name is an alphabetical string.

#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
class Name(object):
    value = None
    def __init__(self, value):
        # value: String 
        # if the string contains any non-alphabet and non-space character,
        # raise a type error
        if is_alphabetic_string(value):
            self.value = value
        else:
            raise TypeError('%s is not a Name!' % value)

    def __str__(self):
        return self.value
#+END_SRC


*** Test the Construction
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
class TestName(TestCase):
    TESTING = True
    def test_name_type(self):
        print "test_name_type"
        new_name = Name("John")
        # correct name
        self.assertEqual(new_name.value, "John")
        # incorrect name
        self.assertRaises(TypeError, Name, "123dasd")
#+END_SRC


** Email


*** Construction

     Email is a type as defined in RFC [[https://tools.ietf.org/html/rfc5321][5321]], [[https://tools.ietf.org/html/rfc5322][5322]] and [[https://tools.ietf.org/html/rfc6531][6531]].
     Following is the constructor for this class.

#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
class Email(object):
    value = None
    def __init__(self, value):
        if not is_email(value):
            raise TypeError('%s is not an email!' % value)
        self.value = value

    def __str__(self):
        return self.value
#+END_SRC



*** Test the Construction
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
class TestEmail(TestCase):
    TESTING = True
    def test_email_type(self):
        print "test_email_type"
        new_email = Email("smith@gmail.com")
        # correct name
        self.assertEqual(new_email.value, "smith@gmail.com")
        # incorrect name
        self.assertRaises(TypeError, Email, "@@@@smithgmail.com")
#+END_SRC



** User


*** Mutable Data

     These are the data associated with User type, which are mutable

     + Name
     + Email
     + Role


*** Definition
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
class User():
    name = None
    email = None
    role = None
    users = []     # this is a static variable, accessed by User.users
#+END_SRC


*** Constructor


**** Implementation

    Signature of the constructor of =User= is as follows:

    #+BEGIN_EXAMPLE
    usr = User(name=<object of Name>, email=<object of Email>, 
              role=[<object of Role>, <object of Role> ...])
    #+END_EXAMPLE

#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def __init__(self, **kwargs):
        if 'email' not in kwargs:
            raise AttributeRequired("email is mandatory")

        if 'name' not in kwargs:
            raise AttributeRequired("name is mandatory")

        if 'role' not in kwargs:
            raise AttributeRequired("role is mandatory")

        self.set_email(kwargs['email'])
        self.set_name(kwargs['name'])
        self.set_role(kwargs['role'])
#        User.users.append(self)
#+END_SRC


**** Test the constructor
 #+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
class TestUser(TestCase):
    TESTING = True

    def setUp(self):
        setup()

    def tearDown(self):
        tearDown()

    def test_user_creation_without_role(self):
        print "test_user_creation_without_role"
        with self.assertRaises(AttributeRequired):
            user = User(name=Name("Robin Smith"), 
                            email=Email("smith@gmail.com"))

    def test_user_creation_with_role(self):
        print "test_user_creation_with_role"
        user = User(name=Name("Robin Smith"), 
                    email=Email("smith@gmail.com"),
                    role=Role.admin)
        self.assertEqual(user.role, Role.admin)
        self.assertEqual(user.email, "smith@gmail.com")

    def test_user_creation_with_wrong_type(self):
        print "test_user_creation_with_wrong_type"
        with self.assertRaises(TypeError):
            user = User(name=Name("Robin@ Smith"), 
                    email=Email("smith@gmail.com"),
                    role=Role.admin)

 #+END_SRC


*** Functions


**** addUser

***** Definition
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    @staticmethod
    def add(user, session):
        if session.user.role is not Role.admin:
            raise NotAuthorizedError("only a user with admin role can add"
                                     " user to the system")
        else:
            existing_users = filter(lambda x: x.email == user.email,
                                    User.users)
            if not existing_users:
                User.users.append(user)
            else:
                raise ConstraintError('user already exists in the system')
#+END_SRC


***** Test

#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
    def test_user_add(self):
        print "test_user_add"
        user = User(name=Name("Robin Smith"), 
                    email=Email("smith@gmail.com"),
                    role=Role.user)
        
        User.add(user, Session.admin)
        self.assertEqual(User.users[1].email, "smith@gmail.com")

    def test_user_duplicate_add(self):
        print "test_user_duplicate_add"
        user = User(name=Name("Robin Smith"), 
                    email=Email("smith@gmail.com"),
                    role=Role.user)
        User.add(user, Session.admin)
        with self.assertRaises(ConstraintError):
            User.add(user, Session.admin)
#+END_SRC


**** showUsers

***** Definition
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    @staticmethod
    def show(session):
        if session not in Session.sessions:
            raise NotAuthorizedError("only a user with admin role or "
                                     "user role can view all the users")
        else:
            existing_users = filter(lambda x: x.email == user.email,
                                    User.users)
            if not existing_users:
                User.users.append(user)
            else:
                raise ConstraintError('user already exists in the system')
#+END_SRC


***** Test

#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
    def test_user_add(self):
        print "test_user_add"
        user = User(name=Name("Robin Smith"), 
                    email=Email("smith@gmail.com"),
                    role=Role.user)
        
        User.add(user, Session.admin)
        self.assertEqual(User.users[1].email, "smith@gmail.com")

    def test_user_duplicate_add(self):
        print "test_user_duplicate_add"
        user = User(name=Name("Robin Smith"), 
                    email=Email("smith@gmail.com"),
                    role=Role.user)
        User.add(user, Session.admin)
        with self.assertRaises(ConstraintError):
            User.add(user, Session.admin)
#+END_SRC


**** setEmail


***** Definition
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def set_email(self, email):
        if not isinstance(email, Email):
            raise TypeError('`email` argument should be of type Email.')
        else:
            self.email = email.value

#+END_SRC


***** Test
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
    def test_set_email_of_user(self):
        print "test_set_email_of_user"
        user = User(name=Name("Robin Smith"), 
                email=Email("smith@gmail.com"),
                role=Role.admin)
        user.set_email(Email("smith1@gmail.com"));
        self.assertEqual(user.email, "smith1@gmail.com")
#+END_SRC


**** setName
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def set_name(self, name):
        if not isinstance(name, Name):
            raise TypeError('`name` argument should be of type Name.')
        else:
            self.name = name.value
#+END_SRC


**** setRole
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def set_role(self, role):
        if not isinstance(role, Role):
            raise TypeError('`role` argument should be of type Role.')
        else:
            self.role = role
#+END_SRC


**** getRole
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def get_role(self):
        return self.role
#+END_SRC


**** getEmail
 #+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def get_email(self):
        return self.email
 #+END_SRC


**** getName
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def get_name(self):
        return self.name
#+END_SRC


**** getAll: Nil --> set[User]

***** Implementation
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    @staticmethod
    def get_all():
        return User.users
#+END_SRC


***** Test getAll
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
    def test_user_get_all(self):
        print "test_user_get_all"
        role = Role.admin
        user = User(name=Name("Termite"), 
                    email=Email("tremite@gmail.com"),
                    role=role)
        
        users = User.get_all()
        for user in users:
            print user.to_client()
        self.assertEqual("admin", users[0].role.name)
#+END_SRC


**** toClient
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def to_client(self):
        return {
            'name': self.name,
            'email': self.email,
            'role': self.role.to_client()
        }
#+END_SRC



** Role

*** Introduction
   A Role has got certain privileges.  In this current application, the
   privileges are understood 
   
   Different types of roles are:
   - Admin :: An admin is an user who can add, modify and delete other users
        except himself.
   - User :: A User is a user who can view all other users and can modify himself.


*** Mutable Data

     These are the data associated with Role type, which are mutable

     + Name


*** Definition
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
class Role():
    name = None
    admin = None
    user = None

    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def to_client(self):
        return {
            'role': self.name
        }

#+END_SRC


** Session

*** Introduction
    A session holds a user.  The maintenance of referential integrity and
    provision of credentials for the operations in the system is done using a
    session. 


*** Mutable Data

    + User


*** Definition
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
class Session():
    user = None
    sessions = []   ## This is a static variable and accessed by Role.roles
#+END_SRC


*** Constructor

    The signature of Role is defined as follows
    #+BEGIN_EXAMPLE
    session = Session(user=<Object of User>)
    #+END_EXAMPLE

#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def __init__(self, **kwargs):
        if 'user' not in kwargs:
            raise AttributeRequired("user is mandatory")

        self.set_user(kwargs['user'])
        Session.sessions.append(self)
#+END_SRC


*** Test Constructor
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
class TestSession(TestCase):
    TESTING = True

    def setUp(self):
        setup()

    def tearDown(self):
        tearDown()

    def test_session_creation(self):
        print "test_session_creation"
        user = User(name=Name("Robin Smith"), 
                    email=Email("smith@gmail.com"),
                    role=Role.user)
        session = Session(user=user)
        self.assertEqual(session.user.role.name, "user")
#+END_SRC


*** Functions


**** setUser

***** Implementation
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def set_user(self, user):
        if not isinstance(user, User):
            raise TypeError('`user` argument should be of type User.')
        else:
            self.user = user
#+END_SRC


***** Test


**** getAll: Nil --> set[Session]


***** Implementation
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    @staticmethod
    def get_all(session):
        if session.user.role is Role.admin:
            return Session.sessions
        else:
            raise NotAuthorizedError("Only an admin can view all the sessions")
#+END_SRC


***** Test getAll: Nil --> set[Session]
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
    def test_session_get_all(self):
        print "test_session_get_all"
        user = User(name=Name("Robin Smith"), 
                    email=Email("smith@gmail.com"),
                    role=Role.user)
        User.add(user, Session.admin)
        sessions = Session.get_all(Session.admin)
        for session in sessions:
            print session.to_client()
#+END_SRC


**** deleteSession 

     Delete a session for a user.  This scenario exists when a user logs out.

#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    @staticmethod
    def del_session(user):
        sessions = filter(lambda session:
                          user.email != session.user.email,
                          Session.sessions)
        Session.sessions = sessions
#+END_SRC

**** getSessionByUser: user > session

***** Definition
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    @staticmethod
    def del_session(user):
        sessions = filter(lambda session:
                          user.email != session.user.email,
                          Session.sessions)
        Session.sessions = sessions
#+END_SRC
***** Test


**** to_client
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def to_client(self):
        return {
            'session': self.user.to_client()
        }

        
#+END_SRC


* Run Test Cases
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
def setup():
    Role.admin = Role("admin")
    Role.user  = Role("user")
    user = User(name=Name("admin user"),
                email=Email("admin-user@gmail.com"),
                role=Role.admin)
    User.admin = user
    Session.admin = Session(user=user)
    print "Session admin"
    print Session.admin
    print Role.admin
    print "Role admin is " 
    print User.admin
    User.add(user, Session.admin)

def tearDown():
    User.users = []
    Session.sessions = []
    Role.admin = None
    Role.user = None


#+END_SRC 

#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
if __name__ == '__main__':
    unittest.main()
#+END_SRC


