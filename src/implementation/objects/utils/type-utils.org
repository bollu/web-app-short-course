#+title:  Type Predicates and Checks
#+SETUPFILE: ../../../org-templates/level-0.org
#+TAGS: boilerplate(b)
#+EXCLUDE_TAGS: boilerplate
This module defines basic type predicates and type checks. 

* Type predicates
A type predicate is a function that takes one argument and
returns a boolean.

** Instance predicate
An instance predicate checks if the argument is in an
instance of a class.
#+name: def_is_inst
#+BEGIN_SRC python
def is_inst(cls):
    def fn(a):
        return isinstance(a, cls)
    return fn

is_int = is_inst(int)
is_str = is_inst(str)
is_dict = is_inst(dict)
#+END_SRC


** =is_alphabetic_str=

    This function take an argument and checks whether the
    argument is an alphabetic string.  An alphabetic string
    consists of one or more alphabetic characters, period or
    space.

#+name: def_is_alphabetic_str
#+BEGIN_SRC  python
import re

def is_alphabetic_str(value):
    if (isinstance(value, str) and re.search('[a-zA-Z. ]+', value)):
        return True
    else:
        return False
#+END_SRC

** =is_email_str=
    Email is a type as defined in RFC [[https://tools.ietf.org/html/rfc5321][5321]], [[https://tools.ietf.org/html/rfc5322][5322]] and [[https://tools.ietf.org/html/rfc6531][6531]].
    Following is the constructor for this class.


#+NAME: def_is_email_str
#+BEGIN_SRC python
def is_email_str(value):
    if isinstance(value, str) and re.search('[^@]+@[^@]+\.[^@]+', value):
        return True
    else:
        return False
#+END_SRC

(We may want to instead use the =validate_email= package of
Python.  See [[http://stackoverflow.com/questions/8022530/python-check-for-valid-email-address][this]] Stack Overflow discussion.)

* Checks
** =check_pred=

A /check/ is a partial function that takes an argument and
acts as as filter.  If the check fails, the check function
raises an exception.  If the check passes, then the function
returns the argument.

We start with implementing a generic function that checks
predicates.  =check_pred= takes a predicate =p= and returns
a function that takes an argument =a= and returns =a= if =a=
satisfies =p=, and raises a =TypeError= otherwise.

#+name: def_check_pred
#+begin_src python
def check_pred(p):
    def fn(a):
        if p(a):
            return a
        else:
            raise TypeError('arg %s does not satisfy type predicate %s' % (a, p))
    return fn

check_alphabetic_str = check_pred(is_alphabetic_str)
check_email_str = check_pred(is_email_str)
#+end_src

*** Tests for =check_pred=
#+name: class_TestCheckPred
#+begin_src python
from type_utils import *

def rem(a, b):
    return a % b

check_even = check_pred(lambda a: isinstance(a,int) & rem(a,2) == 0)

class TestCheckPred(TestCase):
    TESTING = True
    print "test_check_pred"

    def test_check_even(self):
        self.assertEqual(check_even(4), 4)
        self.assertRaises(TypeError, check_even, 5)
        self.assertEqual(check_even(False), False)  # False == 0 in Python
#+end_src
** =check_inst= 

=check_inst= takes a class and returns a function that
checks if its argument is an instance that class.

#+name: def_check_inst
#+begin_src python
def check_inst(cls):
    return check_pred(lambda arg: isinstance(arg, cls))

import types

check_function =  check_inst((types.BuiltinFunctionType, types.FunctionType))
check_dict = check_inst(dict)
check_str = check_inst(str)
check_int = check_inst(int)
check_pos_int = check_pred(lambda arg: check_int(arg) and arg > 0)
check_non_neg_int = check_pred(lambda arg: check_int(arg) and arg >= 0)

#+end_src

** =check_inv=
An invariant is a predicate on a dictionary.  =check-inv=
takes an invariant and an optional class name and returns an
invariant check. 

#+name: def_check_inv
#+BEGIN_SRC python
def check_inv(inv, *name):
    # args is a dictionary
    def fn(args):
        if inv(args):
            args
        else:
            if name == []:
                raise TypeError("invariant fails on args %s" % args)
            else:
                raise TypeError("invariant for class %s fails on args %s" % (name[0], args))
    return fn
#+END_SRC
* Tests
#+name: class_TestCheckAlphabeticStr
#+begin_src python
class TestTypeUtils(TestCase):
    TESTING = True
    """Tests for type_utils"""
    def test_check_alphabetic_str(self):
        print "test_check_alphabetic_str"
        self.assertEqual(check_alphabetic_str("Hello"), "Hello")
        self.assertEqual(check_alphabetic_str("M. N. Ray"), "M. N. Ray")
        self.assertRaises(TypeError, check_alphabetic_str, "123")

    def test_check_inst(self):
        print "test_check_inst"
        self.assertEqual(check_int(3), 3)
        self.assertEqual(check_str("abc"), "abc")
        check_dict({'x': 3, 'y': 5})
        check_function(check_function)

        self.assertRaises(TypeError, check_pos_int, 0)
        self.assertRaises(TypeError, check_non_neg_int, -1)
#+end_src

There are some false positives that slip in with
=alphabetic_str=.  A more accurate definition of
=is_alphabetic_str= should fix this.
#+name: def_test_4
#+begin_src python
    def test_4(self):
        # this looks wierd!  Should it be a name?
        self.assertEqual(check_alphabetic_str(".  ."), ".  .")
#+end_src

* Test Infra													:boilerplate:
** Imports for tests 
#+name: imports_for_tests
#+BEGIN_SRC python
# -*- coding: utf-8 -*-
import unittest
from unittest import TestCase
from datetime import datetime
#+end_src

** Running tests
#+NAME: run_test_cases
#+BEGIN_SRC python
if __name__ == '__main__':
    unittest.main()
#+END_SRC

* Tangling														:boilerplate:
*** sources
**** =type_type_utils.py=
#+BEGIN_SRC python :tangle type_utils.py :eval no :noweb yes
<<def_is_alphabetic_str>>
<<def_is_email_str>>
<<def_check_pred>>
<<def_check_inst>>
<<def_check_inv>>
#+end_src
*** tests
#+BEGIN_SRC python :tangle test_type_utils.py :eval no :noweb yes
<<imports_for_tests>>
<<class_TestCheckPred>>
<<class_TestCheckAlphabeticStr>>
<<def_test_4>>
<<run_test_cases>>
#+end_src




