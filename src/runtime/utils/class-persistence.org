#+TITLE: Class Persistence
#+AUTHOR: VLEAD
#+DATE: [2016-06-09 Thu]
#+SETUPFILE: ../../org-templates/level-0.org
#+TAGS: boilerplate(b)
#+EXCLUDE_TAGS: boilerplate
#+OPTIONS: ^:nil

* Introduction

* Make Persistent
#+NAME: class_ClassPersistentTemplate
#+BEGIN_SRC python
class ClassPersistenceTemplate():

    @staticmethod
    def mk_save(cls):
        def fn(obj):
            for key, value in obj.state.iteritems():
                    obj.key = value

            db.session.add(obj)
            db.session.commit()

        return fn

    @staticmethod
    def mk_update(cls):
        def fn(obj, **args):
            obj.set(**args)
            obj.save()

        return fn

    @staticmethod
    def mk_delete(cls):
        def fn(obj):
            for key, value in obj.state.iteritems():
                    obj.key = value
            db.session.delete(obj)
            db.session.commit()

        return fn

    @staticmethod
    def mk_get_by_id(cls):
        def fn():
            db.session.autoflush = False
            obj = cls.query.get(id)
            return_obj = cls()
            for key in return_obj.state.iteritems():
                    return_obj.state[key] = obj.key
        return staticmethod(fn)

    @staticmethod
    def mk_get_all(cls):
        def fn():
            db.session.autoflush = False
            objs = cls.query.all()
            return_objs = []
            for obj in objs:
                return_obj = cls()
                for key in return_obj.state.iteritems():
                    return_obj.state[key] = obj.key
                return_objs.append(return_obj)

        return staticmethod(fn)

    @staticmethod
    def mk_persistent(cls, **table_args):
        check_dict(table_args)
        for key, value in table_args.iteritems():
            setattr(cls, key, value)
        '''http://stackoverflow.com/questions/9539052/how-to-dynamically-change-base-class-of-instances-at-runtime
'''
        cls.__bases__ = (db.Model, )

        cls.save = classPersistenceTemplate.mk_save(cls)
        cls.update = classPersistenceTemplate.mk_update(cls)
        cls.get_by_id = classPersistenceTemplate.mk_get_by_id(cls)
        cls.get_all = classPersistenceTemplate.mk_get_all(cls)

#+END_SRC
* Tests
#+NAME: persistence_tests
#+BEGIN_SRC python
class TestPersistence(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()


#+END_SRC

* Infra                                                    :boilerplate:

** Source Infra
*** Imports for sources
#+name: imports_for_sources
#+BEGIN_SRC python
# -*- coding: utf-8 -*-
from type_utils import check_dict
from flask_sqlalchemy import SQLAlchemy
db = SQLAlchemy()

#+end_src


** Test Infra
*** Imports for tests 
#+name: imports_for_tests
#+BEGIN_SRC python
# -*- coding: utf-8 -*-
import unittest
from flask.ext.testing import TestCase
from datetime import datetime

from class_persistent_template import *
from runtime.rest.app import create_app

config = {
    'SQLALCHEMY_DATABASE_URI': ''
}

#+end_src

*** Running tests
#+NAME: run_test_cases
#+BEGIN_SRC python
if __name__ == '__main__':
    unittest.main()
#+END_SRC


* Tangling                                                 :boilerplate:

*** sources
#+BEGIN_SRC python :tangle class_persistent_template.py :eval no :noweb yes
<<imports_for_sources>>
<<class_ClassPersistentTemplate>>
#+end_src

*** tests
#+BEGIN_SRC python :tangle test_class_templates.py :eval no :noweb yes
<<imports_for_tests>>
<<run_test_cases>>
#+end_src
