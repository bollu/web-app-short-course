#+TITLE: Class Persistence
#+AUTHOR: VLEAD
#+DATE: [2016-06-09 Thu]
#+SETUPFILE: ../../org-templates/level-0.org
#+TAGS: boilerplate(b)
#+EXCLUDE_TAGS: boilerplate
#+OPTIONS: ^:nil

* Introduction

* Make Persistent
#+NAME: class_ClassPersistentTemplate
#+BEGIN_SRC python

class ClassPersistenceTemplate():

    @staticmethod
    def mk_save(cls):
        def fn(obj):
            for key, value in obj.state.iteritems():
                setattr(obj, key, value)

            db.session.add(obj)
            db.session.commit()

        return fn

    @staticmethod
    def mk_update(cls):
        def fn(obj, **args):
            obj.set(**args)
            obj.save()

        return fn

    @staticmethod
    def mk_delete(cls):
        def fn(obj):
            for key, value in obj.state.iteritems():
                    obj.key = value
            db.session.delete(obj)
            db.session.commit()

        return fn

    @staticmethod
    def mk_get_by_id(cls):
        def fn(id):
            db.session.autoflush = False
            return cls.query.get(id)
        return staticmethod(fn)

    @staticmethod
    def mk_get_all(cls):
        def fn():
            db.session.autoflush = False
            return cls.query.all()
        return staticmethod(fn)

    @staticmethod
    def mk_persistent(cls, **table_args):
        check_dict(table_args)
        for key, value in table_args.iteritems():
            setattr(cls, key, value)
        '''http://stackoverflow.com/questions/9539052/how-to-dynamically-change-base-class-of-instances-at-runtime
'''
        cls = type(cls.__name__, (db.Model,), dict(cls.__dict__))

        cls.save = ClassPersistenceTemplate.mk_save(cls)
        cls.update = ClassPersistenceTemplate.mk_update(cls)
        cls.get_by_id = ClassPersistenceTemplate.mk_get_by_id(cls)
        cls.get_all = ClassPersistenceTemplate.mk_get_all(cls)
        return cls

#+END_SRC
* Tests
#+NAME: persistence_tests
#+BEGIN_SRC python
class TestPersistence(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def testCreationOfAPersistentClass(self):
        print "testCreationOfAPersistentClass"
        args = {"__tablename__": "names",
                "id": db.Column(db.Integer, primary_key=True),
                "name": db.Column(db.String(128), nullable=False)
                }
        PName = ClassPersistenceTemplate.mk_persistent(entities.Name, **args)
        self.setUp()
        p_name = PName(name="Jimi Hendrix")
        p_name.save()
        name = PName.get_by_id(1)
        self.assertEqual(name.get("name"), "Jimi Hendrix")


#+END_SRC

* Infra                                                    :boilerplate:

** Source Infra
*** Imports for sources
#+name: imports_for_sources
#+BEGIN_SRC python
# -*- coding: utf-8 -*-
from type_utils import check_dict
from flask_sqlalchemy import SQLAlchemy
db = SQLAlchemy()

#+end_src


** Test Infra
*** Imports for tests 
#+name: imports_for_tests
#+BEGIN_SRC python
# -*- coding: utf-8 -*-
import unittest
from flask.ext.testing import TestCase
from datetime import datetime
from type_utils import *
from class_templates import *
from class_persistence_template import *
from runtime.rest.app import create_app
import runtime.objects.entities as entities

config = {
    'SQLALCHEMY_DATABASE_URI': ''
}

#+end_src

*** Running tests
#+NAME: run_test_cases
#+BEGIN_SRC python
if __name__ == '__main__':
    unittest.main()
#+END_SRC


* Tangling                                                 :boilerplate:

*** sources
#+BEGIN_SRC python :tangle class_persistence_template.py :eval no :noweb yes
<<imports_for_sources>>
<<class_ClassPersistentTemplate>>
#+end_src

*** tests
#+BEGIN_SRC python :tangle test_class_persistence_template.py :eval no :noweb yes
<<imports_for_tests>>
<<persistence_tests>>
<<run_test_cases>>
#+end_src
